// this file is used to show all capabilities of the Howl programming language
// When changing the file only add new things or comment out `std.debug.print` statements


std :: @import("std")


MyErrorA :: error { 
    DivisionByZero,
    UnknownError,
    InvalidValue,
}

MyEnumB :: enum { 
    Value1,
    Value2,
    Value3,
} 

MyStructB :: struct {
    field1: i32,
    field2: f64,
}

createMyStructB :: fn (a: i32, b: f64) MyErrorA!MyStructB {
    match a {
    |   < 0 => {
                return MyErrorA.InvalidValue
            }
    |    _   => {
                return MyStructB{ .field1 = a, .field2 = b }
           }
    }
}

createMyStructBMaybe :: fn (i: i32, b: f64, c : bool) MyErrorA!?MyStructB {
    match c {
    | true => {
        return None
        }
    | false => {
        match i {
        | < 0 => {
                return  .InvalidValue
                }
        | _ => {
                return MyStructB{ .field1 = i, .field2 = b }
                }
            }
        }
    }
}

divide :: fn (a: i32, b: i32) MyErrorA!i32 {
    return if (b == 0) MyErrorA.DivisionByZero else (a / b)
}

main :: fn () !void {
    
    std.debug.print("Starting division...\n", .{})
    result :: try divide(10, 2)
    std.debug.print("Result of division: {}\n", .{result}) // Result of division: 5

    std.debug.print("Enum value: {}\n", .{MyEnumB.Value1}) // Enum value: 0

    my_struct :: try createMyStructB(42, 3.14)
    std.debug.print("MyStruct: {{field1: {}, field2: {}}}\n", .{my_struct.field1, my_struct.field2}) // MyStruct: {{field1: 42, field2: 3.140000000000000}}

    my_struct2 :: try createMyStructB(-1, 2.71) // This will exit the program with: "Error: 3" 
    std.debug.print("MyStruct2: {{field1: {}, field2: {}}}\n", .{my_struct2.field1, my_struct2.field2})

    // GC array example - demonstrates $ prefix for heap allocation
    simple_gc_array :: $[1, 2, 3]
    first_element :: simple_gc_array[0]
    std.debug.print("GC Array - First element: {}\n", .{first_element})

    // GC struct array example - demonstrates $ prefix with struct initialization  
    people :: $[
        MyStructB{ .field1 = 1, .field2 = 1.1 },
        MyStructB{ .field1 = 2, .field2 = 2.2 },
    ]
    first_person :: people[0]
    std.debug.print("GC Struct Array - First person field1: {}\n", .{first_person.field1})

    result2 :: try divide(10, 0)
    std.debug.print("This line will not be reached due to error.\n", .{})
}

    fn generateCExpressionRecursive(self: *CCodegen, writer: Writer, node_id: ast.NodeId) !void {
        const node = self.arena.getNodeConst(node_id) orelse return;

        switch (node.data) {
            .literal => |literal| {
                try self.generateCLiteral(writer, literal);
            },
            .identifier => |identifier| {
                try writer.writeAll(identifier.name);
            },
            .unary_expr => |unary_expr| {
                // Handle unary expressions like -1, !condition, ~bits
                const op_str = switch (unary_expr.op) {
                    .negate => "-",
                    .not => "!",
                    .bit_not => "~",
                    else => "/* unknown unary op */",
                };
                try writer.writeAll("(");
                try writer.writeAll(op_str);
                try self.generateCExpressionRecursive(writer, unary_expr.operand);
                try writer.writeAll(")");
            },
            .binary_expr => |binary_expr| {
                // Special handling for string concatenation
                if (binary_expr.op == .concat) {
                    try writer.writeAll("howl_string_concat(");
                    try self.generateCExpressionRecursive(writer, binary_expr.left);
                    try writer.writeAll(", ");
                    try self.generateCExpressionRecursive(writer, binary_expr.right);
                    try writer.writeAll(")");
                } else {
                    try writer.writeAll("(");
                    try self.generateCExpressionRecursive(writer, binary_expr.left);
                    try writer.writeAll(" ");
                    try writer.writeAll(binary_expr.op.toString());
                    try writer.writeAll(" ");
                    try self.generateCExpressionRecursive(writer, binary_expr.right);
                    try writer.writeAll(")");
                }
            },
            .member_expr => |member_expr| {
                // Handle member access like std.debug.print
                try self.generateCMemberExpression(writer, member_expr);
            },
            .call_expr => |call_expr| {
                // Check if this is a stdlib function call
                if (try self.isStdlibFunctionCall(call_expr)) {
                    try self.generateCStdlibCall(writer, call_expr);
                } else {
                    // Check if this is a member method call (like h.append())
                    const callee_node = self.arena.getNodeConst(call_expr.callee);
                    if (callee_node) |callee| {
                        if (callee.data == .member_expr) {
                            const member_expr = callee.data.member_expr;
                            try self.generateCMemberMethodCall(writer, member_expr, call_expr.args.items);
                        } else {
                            // Generate regular function call
                            try self.generateCExpressionRecursive(writer, call_expr.callee);
                            try writer.writeAll("(");

                            // Generate arguments
                            for (call_expr.args.items, 0..) |arg_id, i| {
                                if (i > 0) try writer.writeAll(", ");
                                try self.generateCExpressionRecursive(writer, arg_id);
                            }

                            try writer.writeAll(")");
                        }
                    } else {
                        // Fallback
                        try writer.writeAll("/* unknown call */");
                    }
                }
            },
            .struct_init => |struct_init| {
                // Handle anonymous struct syntax .{args}
                if (struct_init.type_name == null) {
                    // This is an anonymous struct for function arguments
                    for (struct_init.fields.items, 0..) |field_init, i| {
                        if (i > 0) try writer.writeAll(", ");
                        try self.generateCExpressionRecursive(writer, field_init.value);
                    }
                } else {
                    // Named struct initialization: .TypeName{ .field = value, ... }
                    const type_name = struct_init.type_name.?;
                    
                    if (struct_init.use_gc) {
                        // Garbage collected initialization: malloc and initialize
                        try writer.print("({s}*)malloc(sizeof({s}))", .{type_name, type_name});
                        // For now, we'll generate a simple malloc call. In a full implementation,
                        // we would need to initialize the allocated memory with the struct values.
                        // This is a basic starting point for GC support.
                    } else {
                        // Generate constructor call: TypeName_init(field_values...)
                        try writer.print("{s}_init(", .{type_name});

                        // Generate field values in constructor order
                        // TODO: Should match the order of fields in struct definition
                        for (struct_init.fields.items, 0..) |field_init, i| {
                            if (i > 0) try writer.writeAll(", ");
                            try self.generateCExpressionRecursive(writer, field_init.value);
                        }
                        try writer.writeAll(")");
                    }
                }
            },
            .array_init => |array_init| {
                if (array_init.use_gc) {
                    // Garbage collected array: malloc and initialize
                    const num_elements = array_init.elements.items.len;
                    
                    // Determine the element type using centralized inference
                    const element_type = if (num_elements > 0) 
                        self.inferNodeCType(array_init.elements.items[0])
                    else 
                        "int32_t";
                    
                    try writer.print("malloc({d} * sizeof({s}))", .{num_elements, element_type});
                    // For now, this is a basic malloc call. In a full implementation,
                    // we would need to initialize the array elements properly.
                } else {
                    // Generate C array literal syntax: {1, 2, 3}
                    try writer.writeAll("{");
                    for (array_init.elements.items, 0..) |element_id, i| {
                        if (i > 0) try writer.writeAll(", ");
                        try self.generateCExpressionRecursive(writer, element_id);
                    }
                    try writer.writeAll("}");
                }
            },
            .if_expr => |if_expr| {
                // Generate C ternary operator: (condition ? then_value : else_value)
                try writer.writeAll("(");
                try self.generateCExpressionRecursive(writer, if_expr.condition);
                try writer.writeAll(" ? ");
                try self.generateCExpressionRecursive(writer, if_expr.then_branch);
                try writer.writeAll(" : ");
                if (if_expr.else_branch) |else_branch| {
                    try self.generateCExpressionRecursive(writer, else_branch);
                } else {
                    try writer.writeAll("/* no else branch */");
                }
                try writer.writeAll(")");
            },
            .compile_target_expr => {
                // @compile.target - output the target as a string literal
                try writer.writeAll("\"c\"");
            },
            .compile_insert_expr => |compile_insert| {
                // @compile.insert("code") - output the inserted code directly
                // This should only be used inside function bodies, not expressions
                try writer.writeAll(compile_insert.code);
            },
            .try_expr => |try_expr| {
                // For try expressions in expression context
                try writer.writeAll("({ ");
                
                // Determine the correct error union type from the expression being tried
                const error_union_type = self.inferErrorUnionTypeFromExpression(try_expr.expression);
                try writer.writeAll(error_union_type);
                try writer.writeAll(" _temp = ");
                try self.generateCExpressionRecursive(writer, try_expr.expression);
                
                if (self.current_function_is_main) {
                    // In main function, use if statement instead of ternary to avoid type mismatch
                    try writer.writeAll("; if (_temp.error < 0) exit(1); _temp.payload; })");
                } else {
                    // In regular functions, propagate error using the correct error union type
                    try writer.writeAll("; if (_temp.error < 0) { ");
                    try writer.writeAll(error_union_type);
                    try writer.writeAll(" _propagated = {_temp.error, 0}; return _propagated; } _temp.payload; })");
                }
            },
            .error_union_type => {
                // Error union types don't generate expressions
                try writer.writeAll("/* error_union_type */");
            },
            .error_literal => |error_literal| {
                // Error literals generate as string constants
                try writer.print("\"{s}\"", .{error_literal.name});
            },
            .index_expr => |index_expr| {
                // Handle array/pointer indexing like array[index]
                try self.generateCExpressionRecursive(writer, index_expr.object);
                try writer.writeAll("[");
                try self.generateCExpressionRecursive(writer, index_expr.index);
                try writer.writeAll("]");
            },
            else => {
                try writer.writeAll("/* Unknown expression */");
            },
        }
    }

// Comprehensive Optional Type Test

// Simple optional function that returns Some or None
getNumber :: fn (positive: bool) ?i32 {
    return if (positive) 42 else None
}

// Optional function with complex conditionals
getValueWithCheck :: fn (x: i32) ?i32 {
    return if (x < 0) None else x * 2
}

// Function that takes optional parameter
printOptional :: fn (opt: ?i32) void {
    match opt {
    | Some => |value| {
        std.debug.print("Value: {}", value)
    }
    | None => {
        std.debug.print("No value")
    }
    }
}

main :: fn () i32 {
    // Test 1: Basic optional creation and assignment
    value1: ?i32 = getNumber(true)
    value2: ?i32 = getNumber(false)
    
    // Test 2: Direct None and Some assignment
    direct_none: ?i32 = None
    direct_some: ?i32 = 10
    
    // Test 3: Complex conditional returns
    complex1 := getValueWithCheck(5)  // Should be Some(10)
    complex2 := getValueWithCheck(-3) // Should be None
    
    // Test 4: Pattern matching with variable binding
    match value1 {
    | Some => |val| {
        std.debug.print("Got value: {}", val)
    }
    | None => {
        std.debug.print("Got None")
    }
    }
    
    // Test 5: Function calls with optional parameters
    printOptional(value1)
    printOptional(value2)
    printOptional(direct_none)
    printOptional(direct_some)
    
    return 0
}
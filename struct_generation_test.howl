// Howl Language - Compile-Time Struct Generation Test
// This test demonstrates the full power of compile-time metaprogramming

// Base struct to work with
Person :: struct {
    name: string,
    age: i32,
    email: string,
}

// Compile-time function that generates a struct based on another struct
generateDerivedStruct :: comp fn (BaseType: type, suffix: string) type {
    // Create a new struct type at compile-time
    field_count := @fieldCount(BaseType)
    
    // For now, create a simple derived struct
    // In a full implementation, we'd iterate through fields and transform them
    DerivedStruct := @createStruct("Derived" + suffix, [
        Field{ name: "id", type: i32 },
        Field{ name: "derived_field", type: string },
    ])
    
    return DerivedStruct
}

// Generate a "View" struct based on Person
PersonView :: generateDerivedStruct(Person, "View")

// Compile-time function that adds fields to a struct dynamically
enhanceStruct :: comp fn (BaseType: type) type {
    // Create a copy of the base struct
    Enhanced := @createStruct("Enhanced", [])
    
    // Add timestamp field
    @addField(Enhanced, "timestamp", i64)
    
    // Add version field 
    @addField(Enhanced, "version", i32)
    
    return Enhanced
}

// Create enhanced version
EnhancedPerson :: enhanceStruct(Person)

// Compile-time function that creates a struct from metadata
createConfigStruct :: comp fn (features: []string) type {
    Config := @createStruct("Config", [])
    
    // In a full implementation, we'd iterate through features
    // and add corresponding fields
    for feature in features {
        if feature == "logging" {
            @addField(Config, "log_level", string)
        } else if feature == "caching" {
            @addField(Config, "cache_size", i32)
        } else if feature == "security" {
            @addField(Config, "auth_token", string)
        }
    }
    
    return Config
}

// Generate config struct based on enabled features
AppConfig :: createConfigStruct(["logging", "caching", "security"])

// Compile-time function that creates a generic container struct
createContainer :: comp fn (ElementType: type, name: string) type {
    Container := @createStruct("Container_" + name, [])
    
    @addField(Container, "items", []ElementType)
    @addField(Container, "count", i32)
    @addField(Container, "capacity", i32)
    
    return Container
}

// Create specialized containers
StringContainer :: createContainer(string, "String")
IntContainer :: createContainer(i32, "Int")
PersonContainer :: createContainer(Person, "Person")

// Compile-time function for reflection-based struct generation
generateReflectionStruct :: comp fn (BaseType: type) type {
    field_count := @fieldCount(BaseType)
    
    ReflectionInfo := @createStruct("ReflectionInfo", [])
    
    @addField(ReflectionInfo, "type_name", string)
    @addField(ReflectionInfo, "field_count", i32)
    
    // In a full implementation, we'd add fields for each field in BaseType
    if @hasField(BaseType, "name") {
        @addField(ReflectionInfo, "has_name_field", bool)
    }
    
    if @hasField(BaseType, "age") {
        @addField(ReflectionInfo, "has_age_field", bool)
    }
    
    return ReflectionInfo
}

// Generate reflection info for Person
PersonReflection :: generateReflectionStruct(Person)

// Main function to test the generated structs
main :: fn () void {
    std.io.print("=== Compile-Time Struct Generation Test ===\n")
    
    // Test that generated structs can be used at runtime
    person_view : PersonView = .{
        .id = 1,
        .derived_field = "test",
    }
    
    enhanced : EnhancedPerson = .{
        .timestamp = 1234567890,
        .version = 1,
    }
    
    app_config : AppConfig = .{
        .log_level = "INFO",
        .cache_size = 1024,
        .auth_token = "secret123",
    }
    
    string_container : StringContainer = .{
        .items = ["hello", "world"],
        .count = 2,
        .capacity = 10,
    }
    
    person_reflection : PersonReflection = .{
        .type_name = "Person",
        .field_count = @fieldCount(Person),
        .has_name_field = true,
        .has_age_field = true,
    }
    
    std.io.print("PersonView ID: {}\n", person_view.id)
    std.io.print("Enhanced timestamp: {}\n", enhanced.timestamp)
    std.io.print("Config log level: {}\n", app_config.log_level)
    std.io.print("String container count: {}\n", string_container.count)
    std.io.print("Person field count: {}\n", person_reflection.field_count)
    
    std.io.print("=== All tests completed successfully! ===\n")
}

// Compile-time validation function
validateStructGeneration :: comp fn () void {
    // Validate that generated structs have expected properties
    person_fields := @fieldCount(Person)
    view_fields := @fieldCount(PersonView) 
    enhanced_fields := @fieldCount(EnhancedPerson)
    config_fields := @fieldCount(AppConfig)
    
    if person_fields != 3 {
        @compileError("Person should have 3 fields")
    }
    
    if view_fields != 2 {
        @compileError("PersonView should have 2 fields") 
    }
    
    if enhanced_fields != 2 {
        @compileError("EnhancedPerson should have 2 fields")
    }
    
    if config_fields != 3 {
        @compileError("AppConfig should have 3 fields")
    }
    
    std.io.print("All compile-time validations passed!\n")
}

// Run compile-time validation
comptime {
    validateStructGeneration()
}